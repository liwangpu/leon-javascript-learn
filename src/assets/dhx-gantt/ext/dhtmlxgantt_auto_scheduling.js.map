{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./sources/core/relations/links_builder.js","webpack:///./sources/utils/helpers.js","webpack:///./sources/ext/auto_scheduling/constraint_types.ts","webpack:///./sources/core/relations/graph_helper.js","webpack:///./sources/core/relations/links_common.js","webpack:///./sources/ext/auto_scheduling/ui_handlers.ts","webpack:///./sources/ext/auto_scheduling/loops_finder.ts","webpack:///./sources/ext/auto_scheduling/connected_groups.ts","webpack:///./sources/ext/auto_scheduling/asap_strategy.ts","webpack:///./sources/ext/auto_scheduling/alap_strategy.ts","webpack:///./sources/ext/auto_scheduling/planner.ts","webpack:///./sources/ext/auto_scheduling/constraints.ts","webpack:///./sources/ext/auto_scheduling.js","webpack:///./sources/ext/auto_scheduling/task_plan.ts"],"names":["root","factory","exports","module","define","amd","a","i","window","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","gantt","getVirtualRoot","mixin","getSubtaskDates","id","config","root_id","type","types","project","$source","$target","$virtual","getLinkedTasks","includePredecessors","startIds","clearCache","_isLinksCacheEnabled","_startLinksCache","relations","visited","result","length","this","_getLinkedTasks","push","_endLinksCache","_collectRelations","rootObj","isChild","visitedLinks","linkKey","successors","_getSuccessors","predecessors","_getPredecessors","hashSum","rootTask","visitedTasks","output","from","undefined","tasksStack","current","pop","isTaskExists","getTask","rel","isSameParent","sourceParent","targetParent","target","hasChild","children","getChildren","units","second","minute","hour","day","week","month","quarter","year","arrayFilter","arr","callback","filter","getSecondsInUnit","unit","forEach","workArray","slice","arrayMap","map","resArray","arrayFind","find","arrayDifference","item","arraySome","hashToArray","hash","sortArrayOfHash","field","desc","compare","b","sort","throttle","timeout","wait","apply","arguments","setTimeout","isArray","obj","Array","isDate","getFullYear","getMonth","getDate","isStringObject","Function","toString","constructor","isNumberObject","isBooleanObject","delay","timer","$cancelTimeout","$pending","args","clearTimeout","$execute","objectKeys","keys","requestAnimationFrame","w","webkitRequestAnimationFrame","msRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","cb","isEventable","attachEvent","detachEvent","ConstraintTypes","helpers","getVertices","ids","len","source","vertices","topologicalSort","edges","$incoming","successor","S","v","L","node","groupAdjacentEdges","edge","res","tarjanStronglyConnectedComponents","verticesHash","stack","edgesFromTasks","recurse","connectedComponents","getVertex","workStack","index","lowLink","onStack","e","Math","min","com","tasks","links","findLoops","cycles","component","_get_linked_task","link","getTarget","task","taskId","_get_link_target","_get_link_source","caching","formattedLinksStash","inheritedSuccessorsStash","inheritedPredecessorsStash","getPredecessorsCache","_formatLink","isSummaryTask","isChildOf","_getImplicitLinks","respectTargetOffset","auto_scheduling_move_projects","targetDates","start_date","end_date","to","getState","drag_id","calculateDuration","fromLength","fromTask","j","toLength","toTask","lag","subtaskLink","_convertToFinishToStartLink","taskParent","_isAutoSchedulable","auto_scheduling","parent","selectOffset","selectSourceLinks","skipChild","eachTask","linksCollection","siblingLink","getLink","siblingId","siblingTask","abs","duration","_getDirectDependencies","selectSuccessors","linksIds","concat","_getInheritedDependencies","cacheCollection","stop","inheritedRelations","eachParent","parentDependencies","_getDirectSuccessors","_getInheritedSuccessors","_getDirectPredecessors","_getInheritedPredecessors","skipInherited","sourceTask","targetTask","finish_to_start","preferredStart","additionalLag","start_to_start","finish_to_finish","start_to_finish","attachUIHandlers","linksBuilder","loopsFinder","connectedGroupsHelper","_attachAutoSchedulingHandlers","_autoScheduleAfterLinkChange","_autoscheduling_in_progress","autoSchedule","_preventCircularLink","isCircularLink","callEvent","getLoopContainingLink","_preventDescendantLink","auto_scheduling_descendant_links","_datesNotEqual","dateA","dateB","taskA","taskB","valueOf","_hasDuration","_notEqualTaskDates","task1","task2","getConstraintType","constraint_date","milestone","getRelations","auto_scheduling_compatibility","getConnectedGroupRelations","movedTask","updateTaskConstraints","schedule_from_end","constraint_type","constraint_types","FNLT","Date","SNET","finalizeTaskConstraints","auto_scheduling_strict","auto_scheduling_initial","changedConstraint","_autoScheduleAfterDND","newTask","relationsArray","skipped","originalLink","splice","presentLinks","updatedLinks","resetToStartLinksLags","_autoSchedule","modifiedTaskId","ext","inlineEditors","autoscheduleColumns_1","state","columnName","editorConfig","getEditorConfig","map_to","oldTask","LoopsFinder","graphHelper","_this","_graphHelper","_linksBuilder","_gantt","allRelations","isLinkExists","findCycles","breadthFirstSearch","currentVertex","queue","groupTasks","groupLinksInternal","groupLinksPublic","shift","linksArray","linksObjects","processedLinks","ConnectedGroupsHelper","getConnectedGroup","group","groups","length_1","findGroups","task_plan_1","AsapStrategy","Create","instance","resolveRelationDate","adjacentLinks","plansHash","minStart","linkId","defaultStart","minRelationDate","relation","constraintDate","getEarliestStartDate","isSmallerOrDefault","project_start","maxEnd","getClosestWorkTime","date","dir","calculateEndDate","masterPlan","currentPlan","TaskPlan","kind","earliestSchedulingStart","earliestSchedulingEnd","isEqual","isFirstSmaller","small","big","smallDate","bigDate","getPredecessorEndDate","plan","predecessorEnd","successorStart","AlapStrategy","maxStart","maxRelationDate","getLatestEndDate","constraintStartDate","isGreaterOrDefault","project_end","latestSchedulingStart","latestSchedulingEnd","getSuccessorStartDate","predecessor","alap_strategy_1","asap_strategy_1","constraint_types_1","AutoSchedulingPlanner","constraintsHelper","_constraintsHelper","_asapStrategy","_alapStrategy","generatePlan","constraints","alapStrategy","asapStrategy","_a","buildWorkCollections","orderedIds","reversedIds","relationsMap","processConstraints","iterateTasks","isAlapTask","isAsapTask","applyProjectPlan","projectPlan","reason","updateTasks","newDate","mainSequence","secondarySequence","isMainSequence","mainSequenceStrategy","secondarySequenceStrategy","currentId","limitPlanDates","processResolvedDate","effectiveStart","earliestStart","earliestEnd","latestStart","latestEnd","conflict","reverse","unshift","constraintType","ASAP","ALAP","processConstraint","ConstraintsHelper","hasConstraint","newPlan","SNLT","FNET","MSO","MFO","getConstraints","store","planner","connectedGroups","getConstraintLimitations","updatedTasks","startTask","preferInitialTaskDates","batchUpdate","payload","updateTask","resetTime","start","end","resetProjectDates","updateParentsAndCallEvents","inclusive","auto_scheduling_compatible","parseDate"],"mappings":"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","file":"ext/dhtmlxgantt_auto_scheduling.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/codebase/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 259);\n","module.exports = function(gantt) {\n\treturn {\n\t\tgetVirtualRoot: function(){\n\t\t\treturn gantt.mixin(\n\t\t\t\tgantt.getSubtaskDates(),\n\t\t\t\t{\n\t\t\t\t\tid: gantt.config.root_id,\n\t\t\t\t\ttype: gantt.config.types.project,\n\t\t\t\t\t$source: [],\n\t\t\t\t\t$target: [],\n\t\t\t\t\t$virtual: true\n\t\t\t\t}\n\t\t\t);\n\t\t},\n\t\n\t\tgetLinkedTasks: function(id, includePredecessors){\n\t\t\tvar startIds = [id];\n\t\n\t\t\t//TODO: format links cache\n\t\t\tvar clearCache = false;\n\t\t\tif(!gantt._isLinksCacheEnabled()) {\n\t\t\t\tgantt._startLinksCache();\n\t\t\t\tclearCache = true;\n\t\t\t}\n\t\t\tvar relations = [];\n\t\t\tvar visited = {};\n\t\t\tvar result = {};\n\t\t\tfor(var i = 0; i < startIds.length; i++){\n\t\t\t\tthis._getLinkedTasks(startIds[i], visited, includePredecessors, result);\n\t\t\t}\n\t\n\t\t\tfor(var i in result){\n\t\t\t\trelations.push(result[i]);\n\t\t\t}\n\t\n\t\t\t//TODO: remove redundant edges before continue https://en.wikipedia.org/wiki/Transitive_reduction\n\t\t\tif(clearCache)\n\t\t\t\tgantt._endLinksCache();\n\t\t\treturn relations;\n\t\t},\n\t\n\t\t_collectRelations: function(rootObj, isChild, includePredecessors, visitedLinks){\n\t\t\tvar successors = gantt._getSuccessors(rootObj, isChild);\n\t\n\t\t\tvar predecessors = [];\n\t\t\tif (includePredecessors) {\n\t\t\t\tpredecessors = gantt._getPredecessors(rootObj, isChild);\n\t\t\t}\n\t\t\t\n\t\t\tvar linkKey;\n\t\t\tvar relations = [];\n\t\t\tfor(var i = 0; i < successors.length; i++){\n\t\t\t\tlinkKey = successors[i].hashSum;\n\t\t\t\tif(visitedLinks[linkKey]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tvisitedLinks[linkKey] = true;\n\t\t\t\t\trelations.push(successors[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(var i = 0; i < predecessors.length; i++){\n\t\t\t\tlinkKey = predecessors[i].hashSum;\n\t\t\t\tif(visitedLinks[linkKey]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tvisitedLinks[linkKey] = true;\n\t\t\t\t\trelations.push(predecessors[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn relations;\n\t\t},\n\t\t_getLinkedTasks: function(rootTask, visitedTasks, includePredecessors, output) {\n\t\t\tvar from = rootTask === undefined ? gantt.config.root_id : rootTask;\n\t\t\tvar visitedTasks = {};\n\t\t\tvar visitedLinks = {};\n\t\t\tvar rootObj;\n\t\n\t\t\tvar tasksStack = [{from: from, includePredecessors: includePredecessors, isChild:false}];\n\t\n\t\t\twhile(tasksStack.length){\n\t\t\t\tvar current = tasksStack.pop();\n\t\t\t\tvar isChild = current.isChild;\n\t\n\t\t\t\tfrom = current.from;\n\t\t\t\tif(visitedTasks[from]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trootObj = gantt.isTaskExists(from) ? gantt.getTask(from) : this.getVirtualRoot();\n\t\t\t\tvisitedTasks[from] = true;\n\t\t\t\t\n\t\t\t\tvar relations = this._collectRelations(rootObj, isChild, includePredecessors, visitedLinks);\n\t\n\t\t\t\tfor(var i=0; i < relations.length; i++){\n\t\t\t\t\tvar rel = relations[i];\n\t\t\t\t\toutput[rel.hashSum] = rel;\n\t\t\t\t\tvar isSameParent = rel.sourceParent == rel.targetParent;\n\t\t\t\t\tvar targetTask = rel.target;\n\t\t\t\t\tif(!visitedTasks[targetTask])\n\t\t\t\t\t\ttasksStack.push({from: rel.target, includePredecessors: true, isChild: isSameParent});\n\t\t\t\t}\n\t\n\t\t\t\tif(gantt.hasChild(rootObj.id)){\n\t\t\t\t\tvar children = gantt.getChildren(rootObj.id);\n\t\t\t\t\tfor(var i=0; i < children.length; i++){\n\t\t\t\t\t\tif(!visitedTasks[children[i]])\n\t\t\t\t\t\t\ttasksStack.push({from: children[i], includePredecessors: true, isChild: true});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn output;\n\t\t}\n\t};\n};","var units = {\n\t\"second\": 1,\n\t\"minute\": 60,\n\t\"hour\": 60 * 60,\n\t\"day\": 60 * 60 * 24,\n\t\"week\": 60 * 60 * 24 * 7,\n\t\"month\": 60 * 60 * 24 * 30,\n\t\"quarter\": 60 * 60 * 24 * 30 * 3,\n\t\"year\": 60 * 60 * 24 * 365\n};\nfunction getSecondsInUnit(unit){\n\treturn units[unit] || units.hour;\n}\n\nfunction forEach(arr, callback) {\n\tif (arr.forEach) {\n\t\tarr.forEach(callback);\n\t} else {\n\t\tvar workArray = arr.slice();\n\t\tfor (var i = 0; i < workArray.length; i++) {\n\t\t\tcallback(workArray[i], i);\n\t\t}\n\t}\n}\n\nfunction arrayMap(arr, callback) {\n\tif (arr.map) {\n\t\treturn arr.map(callback);\n\t} else {\n\t\tvar workArray = arr.slice();\n\t\tvar resArray = [];\n\n\t\tfor (var i = 0; i < workArray.length; i++) {\n\t\t\tresArray.push(callback(workArray[i], i));\n\t\t}\n\t\treturn resArray;\n\t}\n}\n\n\nfunction arrayFind(arr, callback) {\n\tif (arr.find) {\n\t\treturn arr.find(callback);\n\t} else {\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tif (callback(arr[i], i)) {\n\t\t\t\treturn arr[i];\n\t\t\t}\n\t\t}\n\t}\n}\n\n// iframe-safe array type check instead of using instanceof\nfunction isArray(obj){\n\tif(Array.isArray){\n\t\treturn Array.isArray(obj);\n\t}else{\n\t\t// close enough\n\t\treturn (obj && obj.length !== undefined && obj.pop && obj.push);\n\t}\n}\n\n// non-primitive string object, e.g. new String(\"abc\")\nfunction isStringObject(obj){\n\treturn obj && typeof obj === \"object\"\n\t\t&& Function.prototype.toString.call(obj.constructor) === \"function String() { [native code] }\";\n}\n\n// non-primitive number object, e.g. new Number(5)\nfunction isNumberObject(obj){\n\treturn obj && typeof obj === \"object\"\n\t\t&& Function.prototype.toString.call(obj.constructor) === \"function Number() { [native code] }\";\n}\n\n// non-primitive number object, e.g. new Boolean(true)\nfunction isBooleanObject(obj){\n\treturn obj && typeof obj === \"object\"\n\t\t&& Function.prototype.toString.call(obj.constructor) === \"function Boolean() { [native code] }\";\n}\n\nfunction isDate(obj) {\n\tif (obj && typeof obj === \"object\") {\n\t\treturn !!(obj.getFullYear && obj.getMonth && obj.getDate);\n\t} else {\n\t\treturn false;\n\t}\n}\n\nfunction arrayFilter(arr, callback) {\n\tvar result = [];\n\n\tif (arr.filter) {\n\t\treturn arr.filter(callback);\n\t} else {\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tif (callback(arr[i], i)) {\n\t\t\t\tresult[result.length] = arr[i];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\nfunction hashToArray(hash) {\n\tvar result = [];\n\n\tfor (var key in hash) {\n\t\tif (hash.hasOwnProperty(key)) {\n\t\t\tresult.push(hash[key]);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nfunction arraySome(arr, callback) {\n\tif (arr.length === 0) return false;\n\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tif (callback(arr[i], i, arr)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction arrayDifference(arr, callback) {\n\treturn arrayFilter(arr, function(item, i) {\n\t\treturn !callback(item, i);\n\t});\n}\n\nfunction throttle (callback, timeout) {\n\tvar wait = false;\n\n\treturn function () {\n\t\tif (!wait) {\n\t\t\tcallback.apply(null, arguments);\n\t\t\twait = true;\n\t\t\tsetTimeout(function () {\n\t\t\t\twait = false;\n\t\t\t}, timeout);\n\t\t}\n\t};\n}\n\nfunction delay (callback, timeout){\n\tvar timer;\n\n\tvar result = function() {\n\t\tresult.$cancelTimeout();\n\t\tcallback.$pending = true;\n\t\tvar args = Array.prototype.slice.call(arguments);\n\t\ttimer = setTimeout(function(){\n\t\t\tcallback.apply(this, args);\n\t\t\tresult.$pending = false;\n\t\t}, timeout);\n\t};\n\t\n\tresult.$pending = false;\n\tresult.$cancelTimeout = function(){\n\t\tclearTimeout(timer);\n\t\tcallback.$pending = false;\n\t};\n\tresult.$execute = function(){\n\t\tcallback();\n\t\tcallback.$cancelTimeout();\n\t};\n\n\treturn result;\n}\n\nfunction sortArrayOfHash(arr, field, desc) {\n\tvar compare = function(a, b) {\n\t\treturn a < b;\n\t};\n\n\tarr.sort(function(a, b) {\n\t\tif (a[field] === b[field]) return 0;\n\n\t\treturn desc ? compare(a[field], b[field]) : compare(b[field], a[field]);\n\t});\n}\n\nfunction objectKeys(obj) {\n\tif (Object.keys) {\n\t\treturn Object.keys(obj);\n\t}\n\tvar result = [];\n\tvar key;\n\tfor (key in obj) {\n\t\tif (Object.prototype.hasOwnProperty.call(obj, key)) {\n\t\t\tresult.push(key);\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction requestAnimationFrame(callback) {\n\tvar w = window;\n\tvar foundRequestAnimationFrame = w.requestAnimationFrame\n\t\t|| w.webkitRequestAnimationFrame\n\t\t|| w.msRequestAnimationFrame\n\t\t|| w.mozRequestAnimationFrame\n\t\t|| w.oRequestAnimationFrame\n\t\t|| function(cb) { setTimeout(cb, 1000/60); };\n\treturn foundRequestAnimationFrame(callback);\n}\n\nfunction isEventable(obj) {\n\treturn obj.attachEvent && obj.detachEvent;\n}\n\nmodule.exports = {\n\tgetSecondsInUnit: getSecondsInUnit,\n\tforEach: forEach,\n\tarrayMap: arrayMap,\n\tarrayFind: arrayFind,\n\tarrayFilter: arrayFilter,\n\tarrayDifference: arrayDifference,\n\tarraySome: arraySome,\n\thashToArray: hashToArray,\n\tsortArrayOfHash: sortArrayOfHash,\n\tthrottle: throttle,\n\tisArray: isArray,\n\tisDate: isDate,\n\tisStringObject: isStringObject,\n\tisNumberObject: isNumberObject,\n\tisBooleanObject: isBooleanObject,\n\tdelay: delay,\n\tobjectKeys: objectKeys,\n\trequestAnimationFrame: requestAnimationFrame,\n\tisEventable: isEventable\n};","export enum ConstraintTypes {\n\t// As Soon As Possible (ASAP)\n\tASAP = \"asap\",\n\t// As Late As Possible (ALAP)\n\tALAP = \"alap\",\n\t// Start No Earlier Than (SNET)\n\tSNET = \"snet\",\n\t// Start No Later Than (SNLT)\n\tSNLT = \"snlt\",\n\t// Finish No Earlier Than (FNET)\n\tFNET = \"fnet\",\n\t// Finish No Later Than (FNLT)\n\tFNLT = \"fnlt\",\n\t// Must Start On (MSO)\n\tMSO = \"mso\",\n\t// Must Finish On (MFO)\n\tMFO = \"mfo\"\n}","var helpers = require(\"../../utils/helpers\");\n\nmodule.exports = function(){\n\treturn {\n\t\tgetVertices: function(relations){\n\t\t\tvar ids = {};\n\t\t\tvar rel;\n\t\t\tfor(var i = 0, len = relations.length; i < len; i++){\n\t\t\t\trel = relations[i];\n\t\t\t\tids[rel.target] = rel.target;\n\t\t\t\tids[rel.source] = rel.source;\n\t\t\t}\n\n\t\t\tvar vertices = [];\n\t\t\tvar id;\n\t\t\tfor(var i in ids){\n\t\t\t\tid = ids[i];\n\t\t\t\tvertices.push(id);\n\t\t\t}\n\n\t\t\treturn vertices;\n\t\t},\n\t\ttopologicalSort: function(edges){\n\t\t\tvar vertices = this.getVertices(edges);\n\t\t\tvar hash = {};\n\n\t\t\tfor(var i = 0, len = vertices.length; i < len; i ++){\n\t\t\t\thash[vertices[i]] = {id: vertices[i], $source:[], $target:[], $incoming: 0};\n\t\t\t}\n\n\t\t\tfor(var i = 0, len = edges.length; i < len; i++){\n\t\t\t\tvar successor = hash[edges[i].target];\n\t\t\t\tsuccessor.$target.push(i);\n\t\t\t\tsuccessor.$incoming = successor.$target.length;\n\t\t\t\thash[edges[i].source].$source.push(i);\n\n\t\t\t}\n\n\t\t\t// topological sort, Kahn's algorithm\n\t\t\tvar S = vertices.filter(function(v){ return !hash[v].$incoming; });\n\n\t\t\tvar L = [];\n\n\t\t\twhile(S.length){\n\t\t\t\tvar n = S.pop();\n\n\t\t\t\tL.push(n);\n\n\t\t\t\tvar node = hash[n];\n\n\t\t\t\tfor(var i = 0; i < node.$source.length; i++){\n\t\t\t\t\tvar m = hash[edges[node.$source[i]].target];\n\t\t\t\t\tm.$incoming--;\n\t\t\t\t\tif(!m.$incoming){\n\t\t\t\t\t\tS.push(m.id);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn L;\n\n\t\t},\n\t\tgroupAdjacentEdges: function(edges){\n\t\t\tvar res = {};\n\t\t\tvar edge;\n\t\t\tfor(var i = 0, len = edges.length; i < len; i++){\n\t\t\t\tedge = edges[i];\n\t\t\t\tif(!res[edge.source]){\n\t\t\t\t\tres[edge.source] = [];\n\t\t\t\t}\n\t\t\t\tres[edge.source].push(edge);\n\t\t\t}\n\t\t\treturn res;\n\t\t},\n\t\ttarjanStronglyConnectedComponents: function(vertices, edges){\n\t\t\t//https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n\t\t\t// iterative implementation\n\t\t\tvar verticesHash = {};\n\t\t\tvar stack = [];\n\t\t\tvar edgesFromTasks = this.groupAdjacentEdges(edges);\n\t\t\tvar recurse = false;\n\t\t\tvar connectedComponents = [];\n\n\t\t\tfor(var i = 0; i < vertices.length; i++){\n\t\t\t\tvar root = getVertex(vertices[i]);\n\t\t\t\tif(root.visited) continue;\n\t\t\t\tvar workStack = [root];\n\t\t\t\tvar index = 0;\n\t\t\t\twhile(workStack.length){\n\t\t\t\t\tvar v = workStack.pop();\n\n\t\t\t\t\tif(!v.visited){\n\t\t\t\t\t\tv.index = index;\n\t\t\t\t\t\tv.lowLink = index;\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tstack.push(v);\n\t\t\t\t\t\tv.onStack = true;\n\t\t\t\t\t\tv.visited = true;\n\t\t\t\t\t}\n\t\t\t\t\trecurse = false;\n\t\t\t\t\tvar edges = edgesFromTasks[v.id] || [];\n\t\t\t\t\tfor(var e = 0; e < edges.length; e++){\n\t\t\t\t\t\tvar w = getVertex(edges[e].target);\n\t\t\t\t\t\tw.edge = edges[e];\n\t\t\t\t\t\tif(w.index === undefined){\n\t\t\t\t\t\t\tworkStack.push(v);\n\t\t\t\t\t\t\tworkStack.push(w);\n\t\t\t\t\t\t\trecurse = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if(w.onStack){\n\t\t\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.index);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(recurse)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (v.index == v.lowLink){\n\t\t\t\t\t\tvar com = {tasks:[], links:[]};\n\t\t\t\t\t\twhile(true){\n\t\t\t\t\t\t\tw = stack.pop();\n\t\t\t\t\t\t\tw.onStack = false;\n\t\t\t\t\t\t\tcom.tasks.push(w.id);\n\t\t\t\t\t\t\tif(w.edge){\n\t\t\t\t\t\t\t\tcom.links.push(w.edge.id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(w == v){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconnectedComponents.push(com);\n\t\t\t\t\t}\n\t\t\t\t\tif(workStack.length){\n\t\t\t\t\t\tw = v;\n\t\t\t\t\t\tv = workStack[workStack.length - 1];\n\t\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.lowLink);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn connectedComponents;\n\n\t\t\tfunction getVertex(id){\n\t\t\t\tif(!verticesHash[id]){\n\t\t\t\t\tverticesHash[id] = {id: id, onStack:false, index: undefined, lowLink: undefined, edge: undefined};\n\t\t\t\t}\n\n\t\t\t\treturn verticesHash[id];\n\t\t\t}\n\t\t},\n\n\t\tfindLoops: function(relations){\n\t\t\tvar cycles = [];\n\n\t\t\thelpers.forEach(relations, function(rel){\n\t\t\t\tif(rel.target == rel.source)\n\t\t\t\t\tcycles.push([rel.target, rel.source]);\n\t\t\t});\n\n\t\t\tvar vertices = this.getVertices(relations);\n\n\t\t\tvar connectedComponents = this.tarjanStronglyConnectedComponents(vertices, relations);\n\t\t\thelpers.forEach(connectedComponents, function(component){\n\t\t\t\tif(component.tasks.length > 1){\n\t\t\t\t\tcycles.push(component);//{ tasks: [task ids], links: [links ids]}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn cycles;\n\t\t\t//{task:id, link:link.type, lag: link.lag || 0, source: link.source}\n\t\t}\n\t};\n};","module.exports = function (gantt) {\n\t// helpers for building chain of dependencies, used for critical path calculation and for auto scheduling\n\n\tgantt._get_linked_task = function (link, getTarget) {\n\t\tvar task = null;\n\t\tvar taskId = getTarget ? link.target : link.source;\n\n\t\tif (gantt.isTaskExists(taskId)) {\n\t\t\ttask = gantt.getTask(taskId);\n\t\t}\n\n\t\treturn task;\n\t};\n\tgantt._get_link_target = function (link) {\n\t\treturn gantt._get_linked_task(link, true);\n\t};\n\n\tgantt._get_link_source = function (link) {\n\t\treturn gantt._get_linked_task(link, false);\n\t};\n\n\tvar caching = false;\n\tvar formattedLinksStash = {};\n\tvar inheritedSuccessorsStash = {};\n\tvar inheritedPredecessorsStash = {};\n\tvar getPredecessorsCache = {};\n\n\n\tgantt._isLinksCacheEnabled = function () {\n\t\treturn caching;\n\t};\n\tgantt._startLinksCache = function () {\n\t\tformattedLinksStash = {};\n\t\tinheritedSuccessorsStash = {};\n\t\tinheritedPredecessorsStash = {};\n\t\tgetPredecessorsCache = {};\n\t\tcaching = true;\n\t};\n\tgantt._endLinksCache = function () {\n\t\tformattedLinksStash = {};\n\t\tinheritedSuccessorsStash = {};\n\t\tinheritedPredecessorsStash = {};\n\t\tgetPredecessorsCache = {};\n\t\tcaching = false;\n\t};\n\n\tgantt._formatLink = function (link) {\n\n\n\t\tif (caching && formattedLinksStash[link.id]) {\n\t\t\treturn formattedLinksStash[link.id];\n\t\t}\n\n\t\tvar relations = [];\n\t\tvar target = this._get_link_target(link);\n\t\tvar source = this._get_link_source(link);\n\n\t\tif (!(source && target)) {\n\t\t\treturn relations;\n\t\t}\n\n\t\tif ((gantt.isSummaryTask(target) && gantt.isChildOf(source.id, target.id)) || (gantt.isSummaryTask(source) && gantt.isChildOf(target.id, source.id))) {\n\t\t\treturn relations;\n\t\t}\n\n\n\t\t// there are three kinds of connections at this point\n\t\t// task -> task - regular link\n\t\t// task -> project - transform it into set of regular links (task -> [each subtask]), use offset beetween subtask and project dates as lag, in order not to change mutual positions of subtasks inside a project\n\t\t// project -> task - transform it into ([each subtask] -> task) links\n\t\t// project -> project - transform it into ([each subtask of p1] -> [each subtask of p2]) links\n\n\t\tvar from = this._getImplicitLinks(link, source, function (c) {\n\t\t\treturn 0;\n\t\t}, true);\n\n\t\tvar respectTargetOffset = gantt.config.auto_scheduling_move_projects;\n\t\tvar targetDates = this.isSummaryTask(target) ? this.getSubtaskDates(target.id) : {\n\t\t\tstart_date: target.start_date,\n\t\t\tend_date: target.end_date\n\t\t};\n\t\tvar to = this._getImplicitLinks(link, target, function (c) {\n\t\t\tif (!respectTargetOffset) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\n\t\t\t\tif (!c.$target.length && !(gantt.getState().drag_id == c.id)) {// drag_id - virtual lag shouldn't restrict task that is being moved inside project\n\t\t\t\t\treturn gantt.calculateDuration({\n\t\t\t\t\t\tstart_date: targetDates.start_date,\n\t\t\t\t\t\tend_date: c.start_date,\n\t\t\t\t\t\ttask: source\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tfor (var i = 0, fromLength = from.length; i < fromLength; i++) {\n\t\t\tvar fromTask = from[i];\n\t\t\tfor (var j = 0, toLength = to.length; j < toLength; j++) {\n\t\t\t\tvar toTask = to[j];\n\n\t\t\t\tvar lag = fromTask.lag * 1 + toTask.lag * 1;\n\n\t\t\t\tvar subtaskLink = {\n\t\t\t\t\tid: link.id,\n\t\t\t\t\ttype: link.type,\n\t\t\t\t\tsource: fromTask.task,\n\t\t\t\t\ttarget: toTask.task,\n\t\t\t\t\tlag: (link.lag * 1 || 0) + lag\n\t\t\t\t};\n\n\t\t\t\trelations.push(gantt._convertToFinishToStartLink(toTask.task, subtaskLink, source, target, fromTask.taskParent, toTask.taskParent));\n\t\t\t}\n\t\t}\n\n\t\tif (caching)\n\t\t\tformattedLinksStash[link.id] = relations;\n\n\t\treturn relations;\n\t};\n\n\tgantt._isAutoSchedulable = function (task) {\n\t\treturn task.auto_scheduling !== false;\n\t};\n\n\tgantt._getImplicitLinks = function (link, parent, selectOffset, selectSourceLinks) {\n\t\tvar relations = [];\n\n\t\tif (this.isSummaryTask(parent)) {\n\n\t\t\t// if the summary task contains multiple chains of linked tasks - no need to consider every task of the chain,\n\t\t\t// it will be enough to check the first/last tasks of the chain\n\t\t\t// special conditions if there are unscheduled tasks in the chain, or negative lag values that put the end date of the successor task prior to its predecessors' date\n\t\t\tvar children = {};\n\t\t\tthis.eachTask(function (c) {\n\t\t\t\tif (!this.isSummaryTask(c)) {\n\t\t\t\t\tchildren[c.id] = c;\n\t\t\t\t}\n\t\t\t}, parent.id);\n\n\t\t\tvar skipChild;\n\n\t\t\tfor (var c in children) {\n\t\t\t\tvar task = children[c];\n\t\t\t\tvar linksCollection = selectSourceLinks ? task.$source : task.$target;\n\n\t\t\t\tskipChild = false;\n\n\t\t\t\tfor (var l = 0; l < linksCollection.length; l++) {\n\t\t\t\t\tvar siblingLink = gantt.getLink(linksCollection[l]);\n\t\t\t\t\tvar siblingId = selectSourceLinks ? siblingLink.target : siblingLink.source;\n\t\t\t\t\tvar siblingTask = children[siblingId];\n\t\t\t\t\tif (siblingTask && task.auto_scheduling !== false && siblingTask.auto_scheduling !== false) {\n\t\t\t\t\t\tif ((siblingLink.target == siblingTask.id && Math.abs(siblingLink.lag) <= siblingTask.duration) ||\n\t\t\t\t\t\t\t(siblingLink.target == task.id && Math.abs(siblingLink.lag) <= task.duration)) {\n\t\t\t\t\t\t\tskipChild = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!skipChild) {\n\t\t\t\t\trelations.push({ task: task.id, taskParent: task.parent, lag: selectOffset(task) });\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\trelations.push({ task: parent.id, taskParent: parent.parent, lag: 0 });\n\t\t}\n\n\t\treturn relations;\n\t};\n\n\tgantt._getDirectDependencies = function (task, selectSuccessors) {\n\n\t\tvar links = [],\n\t\t\tsuccessors = [];\n\n\t\tvar linksIds = selectSuccessors ? task.$source : task.$target;\n\n\t\tfor (var i = 0; i < linksIds.length; i++) {\n\t\t\tvar link = this.getLink(linksIds[i]);\n\t\t\tif (this.isTaskExists(link.source) && this.isTaskExists(link.target)) {\n\t\t\t\tvar target = this.getTask(link.target);\n\t\t\t\tif (this._isAutoSchedulable(target)) {\n\t\t\t\t\tlinks.push(this.getLink(linksIds[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i < links.length; i++) {\n\t\t\tsuccessors = successors.concat(this._formatLink(links[i]));\n\t\t}\n\n\t\treturn successors;\n\t};\n\n\tgantt._getInheritedDependencies = function (task, selectSuccessors) {\n\n\t\t//var successors = [];\n\t\tvar stop = false;\n\t\tvar inheritedRelations = [];\n\t\tvar cacheCollection;\n\t\tif (this.isTaskExists(task.id)) {\n\t\t\tthis.eachParent(function (parent) {\n\t\t\t\tif (stop)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (caching) {\n\t\t\t\t\tcacheCollection = selectSuccessors ? inheritedSuccessorsStash : inheritedPredecessorsStash;\n\t\t\t\t\tif (cacheCollection[parent.id]) {\n\t\t\t\t\t\tinheritedRelations = inheritedRelations.concat(cacheCollection[parent.id]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar parentDependencies;\n\t\t\t\tif (this.isSummaryTask(parent)) {\n\t\t\t\t\tif (!this._isAutoSchedulable(parent)) {\n\t\t\t\t\t\tstop = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparentDependencies = this._getDirectDependencies(parent, selectSuccessors);\n\t\t\t\t\t\tif (caching) {\n\t\t\t\t\t\t\tcacheCollection[parent.id] = parentDependencies;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tinheritedRelations = inheritedRelations.concat(parentDependencies);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}, task.id, this);\n\t\t}\n\n\t\treturn inheritedRelations;\n\t};\n\n\n\tgantt._getDirectSuccessors = function (task) {\n\t\treturn this._getDirectDependencies(task, true);\n\t};\n\n\tgantt._getInheritedSuccessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, true);\n\t};\n\n\tgantt._getDirectPredecessors = function (task) {\n\t\treturn this._getDirectDependencies(task, false);\n\t};\n\n\tgantt._getInheritedPredecessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, false);\n\t};\n\n\tgantt._getSuccessors = function (task, skipInherited) {\n\t\tvar successors = this._getDirectSuccessors(task);\n\t\tif (skipInherited) {\n\t\t\treturn successors;\n\t\t} else {\n\t\t\treturn successors.concat(this._getInheritedSuccessors(task));\n\t\t}\n\t};\n\n\tgantt._getPredecessors = function (task, skipInherited) {\n\t\tvar key = task.id + skipInherited;\n\t\tvar result;\n\n\t\tif (caching && getPredecessorsCache[key]) {\n\t\t\treturn getPredecessorsCache[key];\n\t\t}\n\n\t\tvar predecessors = this._getDirectPredecessors(task);\n\t\tif (skipInherited) {\n\t\t\tresult = predecessors;\n\t\t} else {\n\t\t\tresult = predecessors.concat(this._getInheritedPredecessors(task));\n\t\t}\n\t\tif (caching) {\n\t\t\tgetPredecessorsCache[key] = result;\n\t\t}\n\t\treturn result;\n\t};\n\n\n\tgantt._convertToFinishToStartLink = function (id, link, sourceTask, targetTask, sourceParent, targetParent) {\n\t\t// convert finish-to-finish, start-to-finish and start-to-start to finish-to-start link and provide some additional properties\n\t\tvar res = {\n\t\t\ttarget: id,\n\t\t\tlink: gantt.config.links.finish_to_start,\n\t\t\tid: link.id,\n\t\t\tlag: link.lag || 0,\n\t\t\tsource: link.source,\n\t\t\tpreferredStart: null,\n\t\t\tsourceParent: sourceParent,\n\t\t\ttargetParent: targetParent,\n\t\t\thashSum: null\n\t\t};\n\n\t\tvar additionalLag = 0;\n\t\tswitch (link.type) {\n\t\t\tcase gantt.config.links.start_to_start:\n\t\t\t\tadditionalLag = -sourceTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.finish_to_finish:\n\t\t\t\tadditionalLag = -targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.start_to_finish:\n\t\t\t\tadditionalLag = -sourceTask.duration - targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tadditionalLag = 0;\n\t\t}\n\n\t\tres.lag += additionalLag;\n\t\tres.hashSum = res.lag + \"_\" + res.link + \"_\" + res.source + \"_\" + res.target;\n\t\treturn res;\n\t};\n};","import { ConnectedGroupsHelper } from \"./connected_groups\";\n\nexport function attachUIHandlers(\n\tgantt: any,\n\tlinksBuilder: any,\n\tloopsFinder: any,\n\tconnectedGroupsHelper: ConnectedGroupsHelper\n) {\n\tlet _attachAutoSchedulingHandlers = function() {\n\t\tfunction _autoScheduleAfterLinkChange(id: LinkID, link: ILink) {\n\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\tgantt.autoSchedule(link.source);\n\t\t\t}\n\t\t}\n\n\t\tgantt.attachEvent(\"onAfterLinkUpdate\", _autoScheduleAfterLinkChange);\n\t\tgantt.attachEvent(\"onAfterLinkAdd\", _autoScheduleAfterLinkChange);\n\n\t\tgantt.attachEvent(\"onAfterLinkDelete\", function(id: LinkID, link: ILink) {\n\t\t\tif (\n\t\t\t\tgantt.config.auto_scheduling &&\n\t\t\t\t!gantt._autoscheduling_in_progress &&\n\t\t\t\tgantt.isTaskExists(link.target)\n\t\t\t) {\n\t\t\t\t// after link deleted - auto schedule target for other relations that may be left\n\t\t\t\tconst target = gantt.getTask(link.target);\n\t\t\t\tconst predecessors = gantt._getPredecessors(target);\n\t\t\t\tif (predecessors.length) {\n\t\t\t\t\tgantt.autoSchedule(predecessors[0].source, false);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tgantt.attachEvent(\"onParse\", function() {\n\t\t\tif (\n\t\t\t\tgantt.config.auto_scheduling &&\n\t\t\t\tgantt.config.auto_scheduling_initial\n\t\t\t) {\n\t\t\t\tgantt.autoSchedule();\n\t\t\t}\n\t\t});\n\n\t\tfunction _preventCircularLink(id: LinkID, link: ILink): boolean {\n\t\t\tif (gantt.isCircularLink(link)) {\n\t\t\t\tgantt.callEvent(\"onCircularLinkError\", [\n\t\t\t\t\tlink,\n\t\t\t\t\tloopsFinder.getLoopContainingLink(link)\n\t\t\t\t]);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfunction _preventDescendantLink(id: LinkID, link: ILink): boolean {\n\t\t\tconst source = gantt.getTask(link.source);\n\t\t\tconst target = gantt.getTask(link.target);\n\n\t\t\tif (!gantt.config.auto_scheduling_descendant_links) {\n\t\t\t\tif (\n\t\t\t\t\t(gantt.isChildOf(source.id, target.id) &&\n\t\t\t\t\t\tgantt.isSummaryTask(target)) ||\n\t\t\t\t\t(gantt.isChildOf(target.id, source.id) && gantt.isSummaryTask(source))\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tgantt.attachEvent(\"onBeforeLinkAdd\", _preventCircularLink);\n\t\tgantt.attachEvent(\"onBeforeLinkAdd\", _preventDescendantLink);\n\t\tgantt.attachEvent(\"onBeforeLinkUpdate\", _preventCircularLink);\n\t\tgantt.attachEvent(\"onBeforeLinkUpdate\", _preventDescendantLink);\n\n\t\tfunction _datesNotEqual(\n\t\t\tdateA: Date,\n\t\t\tdateB: Date,\n\t\t\ttaskA: ITask,\n\t\t\ttaskB: ITask\n\t\t): boolean {\n\t\t\tif (!!dateA !== !!dateB) {\n\t\t\t\t// if one of dates is empty or null and the other is not\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (!dateA && !dateB) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (dateA.valueOf() > dateB.valueOf()) {\n\t\t\t\treturn gantt._hasDuration({\n\t\t\t\t\tstart_date: dateB,\n\t\t\t\t\tend_date: dateA,\n\t\t\t\t\ttask: taskB\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn gantt._hasDuration({\n\t\t\t\t\tstart_date: dateA,\n\t\t\t\t\tend_date: dateB,\n\t\t\t\t\ttask: taskA\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tfunction _notEqualTaskDates(task1: ITask, task2: ITask): boolean {\n\t\t\tif (_datesNotEqual(task1.start_date, task2.start_date, task1, task2)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (gantt.getConstraintType(task1) !== gantt.getConstraintType(task2)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t_datesNotEqual(\n\t\t\t\t\ttask1.constraint_date,\n\t\t\t\t\ttask2.constraint_date,\n\t\t\t\t\ttask1,\n\t\t\t\t\ttask2\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t_datesNotEqual(task1.start_date, task2.start_date, task1, task2) ||\n\t\t\t\t((_datesNotEqual(task1.end_date, task2.end_date, task1, task2) ||\n\t\t\t\t\ttask1.duration !== task2.duration) &&\n\t\t\t\t\ttask1.type !== gantt.config.types.milestone)\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfunction getRelations(id: TaskID) {\n\t\t\t// collect relations before drag and drop  in order to have original positions of subtasks within project since they are used as lag when moving dependent project\n\n\t\t\t// TODO: remove in 7.0\n\t\t\tif (gantt.config.auto_scheduling_compatibility) {\n\t\t\t\t// collect only downstream dependencies since there is no backward or ALAP scheduling in pre 6.1 auto scheduling\n\t\t\t\treturn linksBuilder.getLinkedTasks(id, true);\n\t\t\t} else {\n\t\t\t\t// get all connected group (both upstream and downstream dependencies)\n\t\t\t\treturn connectedGroupsHelper.getConnectedGroupRelations(id);\n\t\t\t}\n\t\t}\n\n\t\tlet relations;\n\t\tlet movedTask;\n\t\tgantt.attachEvent(\"onBeforeTaskDrag\", function(\n\t\t\tid: TaskID,\n\t\t\tmode: string,\n\t\t\ttask: ITask\n\t\t) {\n\t\t\tif (\n\t\t\t\tgantt.config.auto_scheduling &&\n\t\t\t\tgantt.config.auto_scheduling_move_projects\n\t\t\t) {\n\t\t\t\t// collect relations before drag and drop  in order to have original positions of subtasks within project since they are used as lag when moving dependent project\n\t\t\t\trelations = getRelations(id);\n\n\t\t\t\tmovedTask = id;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\n\t\tfunction resetToStartLinksLags(taskId, relationsArray) {\n\t\t\t// task duration is used as lag when converting start_to_start and start_to_finish into finish_to_start links\n\t\t\t// recalculate these links if task duration has changed\n\n\t\t\tlet skipped = false;\n\t\t\tfor (let i = 0; i < relations.length; i++) {\n\t\t\t\tconst originalLink = gantt.getLink(relationsArray[i].id);\n\t\t\t\tif (\n\t\t\t\t\toriginalLink &&\n\t\t\t\t\t(originalLink.type === gantt.config.links.start_to_start ||\n\t\t\t\t\t\toriginalLink.type === gantt.config.links.start_to_finish)\n\t\t\t\t) {\n\t\t\t\t\trelationsArray.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t\tskipped = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (skipped) {\n\t\t\t\tconst presentLinks = {};\n\t\t\t\tfor (let i = 0; i < relationsArray.length; i++) {\n\t\t\t\t\tpresentLinks[relationsArray[i].id] = true;\n\t\t\t\t}\n\n\t\t\t\tconst updatedLinks = getRelations(taskId);\n\n\t\t\t\tfor (let i = 0; i < updatedLinks.length; i++) {\n\t\t\t\t\tif (!presentLinks[updatedLinks[i].id]) {\n\t\t\t\t\t\trelationsArray.push(updatedLinks[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction updateTaskConstraints(task){\n\t\t\tif (gantt.config.schedule_from_end) {\n\t\t\t\ttask.constraint_type = gantt.config.constraint_types.FNLT;\n\t\t\t\ttask.constraint_date = new Date(task.end_date);\n\t\t\t} else {\n\t\t\t\ttask.constraint_type = gantt.config.constraint_types.SNET;\n\t\t\t\ttask.constraint_date = new Date(task.start_date);\n\t\t\t}\n\t\t}\n\n\t\tfunction finalizeTaskConstraints(task){\n\t\t\t// TODO: remove in 7.0\n\t\t\tif (gantt.config.auto_scheduling_compatibility && gantt.config.auto_scheduling_strict) {\n\t\t\t\tif (task.constraint_type === gantt.config.constraint_types.SNET ||\n\t\t\t\t\ttask.constraint_type === gantt.config.constraint_types.FNLT) {\n\t\t\t\t\t\ttask.constraint_type = null;\n\t\t\t\t\t\ttask.constraint_date = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst _autoScheduleAfterDND = function(taskId, task) {\n\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\tconst newTask = gantt.getTask(taskId);\n\n\t\t\t\tif (_notEqualTaskDates(task, newTask)) {\n\t\t\t\t\tupdateTaskConstraints(newTask);\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tgantt.config.auto_scheduling_move_projects &&\n\t\t\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\t\t\tmovedTask == taskId\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tgantt.calculateDuration(task) !== gantt.calculateDuration(newTask)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// task duration is used as lag when converting start_to_start and start_to_finish into finish to start links\n\t\t\t\t\t\t\t// recalculate these links if task duration has changed\n\t\t\t\t\t\t\tresetToStartLinksLags(taskId, relations);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgantt._autoSchedule(taskId, relations);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgantt.autoSchedule(newTask.id);\n\t\t\t\t\t}\n\n\t\t\t\t\tfinalizeTaskConstraints(newTask);\n\t\t\t\t}\n\t\t\t}\n\t\t\trelations = null;\n\t\t\tmovedTask = null;\n\t\t\treturn true;\n\t\t};\n\n\n\n\n\t\tlet modifiedTaskId = null;\n\t\tif (gantt.ext && gantt.ext.inlineEditors) {\n\t\t\tconst inlineEditors = gantt.ext.inlineEditors;\n\t\t\tconst autoscheduleColumns = {\n\t\t\t\tstart_date: true,\n\t\t\t\tend_date: true,\n\t\t\t\tduration: true,\n\t\t\t\tconstraint_type: true,\n\t\t\t\tconstraint_date: true\n\t\t\t};\n\n\t\t\tinlineEditors.attachEvent(\"onBeforeSave\", function(state) {\n\t\t\t\tif (autoscheduleColumns[state.columnName]) {\n\t\t\t\t\tmodifiedTaskId = state.id;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\n\t\tlet changedConstraint;\n\t\tfunction onBeforeLigthboxSaveHandler(taskId: TaskID, task: ITask): boolean {\n\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\tchangedConstraint = false;\n\t\t\t\tconst oldTask = gantt.getTask(taskId);\n\t\t\t\tif (_notEqualTaskDates(task, oldTask)) {\n\t\t\t\t\tmodifiedTaskId = taskId;\n\t\t\t\t\tif(gantt.getConstraintType(task) !== gantt.getConstraintType(oldTask) ||\n\t\t\t\t\t\t+task.constraint_date !== +oldTask.constraint_date\n\t\t\t\t\t){\n\t\t\t\t\t\tchangedConstraint = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tfunction onAfterTaskUpdateHandler(taskId: TaskID, task: ITask): boolean {\n\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\tif (\n\t\t\t\t\tmodifiedTaskId &&\n\t\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\t\tmodifiedTaskId == taskId\n\t\t\t\t) {\n\t\t\t\t\tmodifiedTaskId = null;\n\t\t\t\t\tif(!changedConstraint){\n\t\t\t\t\t\tupdateTaskConstraints(task);\n\t\t\t\t\t}\n\t\t\t\t\tgantt.autoSchedule(task.id);\n\n\t\t\t\t\tif(!changedConstraint){\n\t\t\t\t\t\tfinalizeTaskConstraints(task);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tgantt.attachEvent(\"onBeforeTaskChanged\", function(\n\t\t\tid: TaskID,\n\t\t\tmode: string,\n\t\t\ttask: ITask\n\t\t) {\n\t\t\treturn _autoScheduleAfterDND(id, task);\n\t\t});\n\n\t\tif(gantt.ext.inlineEditors){\n\t\t\tgantt.ext.inlineEditors.attachEvent(\"onBeforeSave\", function(state){\n\t\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\t\tconst api = gantt.ext.inlineEditors;\n\t\t\t\t\tconst editorConfig = api.getEditorConfig(state.columnName);\n\t\t\t\t\tif(editorConfig.map_to === \"start_date\" || editorConfig.map_to === \"end_date\" || editorConfig.map_to === \"duration\"){\n\t\t\t\t\t\tmodifiedTaskId = state.id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\n\t\tgantt.attachEvent(\"onLightboxSave\", onBeforeLigthboxSaveHandler);\n\t\tgantt.attachEvent(\"onAfterTaskUpdate\", onAfterTaskUpdateHandler);\n\t};\n\n\tgantt.attachEvent(\"onGanttReady\", function() {\n\t\t_attachAutoSchedulingHandlers();\n\t\t// attach handlers only when initialized for the first time\n\t\t_attachAutoSchedulingHandlers = function() { };\n\t});\n}\n","export class LoopsFinder {\n\tprivate _linksBuilder: any;\n\tprivate _graphHelper: any;\n\tprivate _gantt: any;\n\tconstructor(gantt: any, graphHelper: any, linksBuilder: any) {\n\t\tthis._linksBuilder = linksBuilder;\n\t\tthis._graphHelper = graphHelper;\n\t\tthis._gantt = gantt;\n\t}\n\tisCircularLink = (link: ILink): boolean => {\n\t\treturn !!this.getLoopContainingLink(link);\n\t}\n\n\tgetLoopContainingLink = (link: ILink): any => {\n\t\tconst graphHelper = this._graphHelper;\n\t\tconst linksBuilder = this._linksBuilder;\n\t\tconst gantt = this._gantt;\n\n\t\tlet allRelations = linksBuilder.getLinkedTasks();\n\t\tif (!gantt.isLinkExists(link.id)) {\n\t\t\tallRelations = allRelations.concat(gantt._formatLink(link));\n\t\t}\n\n\t\tconst cycles = graphHelper.findLoops(allRelations);\n\n\t\tconst found = false;\n\t\tfor (let i = 0; i < cycles.length && !found; i++) {\n\t\t\tconst links = cycles[i].links;\n\t\t\tfor (let j = 0; j < links.length; j++) {\n\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\tif (links[j] == link.id) {\n\t\t\t\t\treturn cycles[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tfindCycles = () => {\n\t\tconst graphHelper = this._graphHelper;\n\t\tconst linksBuilder = this._linksBuilder;\n\n\t\tconst allRelations = linksBuilder.getLinkedTasks();\n\t\treturn graphHelper.findLoops(allRelations);\n\t}\n}\n","interface IFlagHash {\n\t[id: string]: boolean;\n}\n\nfunction findGroups(links: IInternalLink[]): IConnectedGroup[] {\n\tconst visited: IFlagHash = {};\n\tconst groups = [];\n\tlet source: TaskID;\n\tlet target: TaskID;\n\tlet root: TaskID;\n\t// main loop - find any unvisited vertex from the input array and\n\t// treat it as the source, then perform a breadth first search from\n\t// it. All vertices visited from this search belong to the same group\n\tfor (let i = 0; i < links.length; i++) {\n\t\tsource = links[i].source;\n\t\ttarget = links[i].target;\n\t\troot = null;\n\t\tif (!visited[source]) {\n\t\t\troot = source;\n\t\t} else if (!visited[target]) {\n\t\t\troot = target;\n\t\t}\n\t\tif (root) {\n\t\t\t// there is an unvisited vertex in this pair.\n\t\t\t// perform a breadth first search, and push the resulting\n\t\t\t// group onto the list of all groups\n\t\t\tconst length = links.length;\n\t\t\tgroups.push(breadthFirstSearch(root, links, visited));\n\t\t\tif (length !== links.length) {\n\t\t\t\ti = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn groups;\n}\n\n// Breadth First Search function\n// v is the source vertex\n// links is the input array, which contains all gantt relations\n// visited is a dictionary for keeping track of whether a node is visited\nfunction breadthFirstSearch(\n\tv: TaskID,\n\tlinks: IInternalLink[],\n\tvisited: IFlagHash\n): IConnectedGroupsDetailed {\n\tconst queue: TaskID[] = [v];\n\tconst groupTasks: TaskID[] = [];\n\tconst groupLinksInternal: { [hashSum: string]: IInternalLink } = {};\n\tconst groupLinksPublic: { [id: string]: boolean } = {};\n\n\tlet currentVertex: TaskID;\n\twhile (queue.length > 0) {\n\t\tcurrentVertex = queue.shift();\n\t\tif (!visited[currentVertex]) {\n\t\t\tvisited[currentVertex] = true;\n\t\t\tgroupTasks.push(currentVertex);\n\t\t\t// go through the input array to find vertices that are\n\t\t\t// directly adjacent to the current vertex, and put them\n\t\t\t// onto the queue\n\t\t\tfor (let i = 0; i < links.length; i++) {\n\t\t\t\tconst link = links[i];\n\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\tif ((link.source == currentVertex || link.sourceParent == currentVertex)) {\n\t\t\t\t\tif (!visited[link.target]) {\n\t\t\t\t\t\tqueue.push(link.target);\n\t\t\t\t\t\tgroupLinksPublic[link.id] = true;\n\t\t\t\t\t\tlinks.splice(i, 1);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t\tgroupLinksInternal[link.hashSum] = link;\n\n\t\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\t} else if ((link.target == currentVertex || link.targetParent == currentVertex)) {\n\t\t\t\t\tif (!visited[link.source]) {\n\t\t\t\t\t\tqueue.push(link.source);\n\t\t\t\t\t\tgroupLinksPublic[link.id] = true;\n\t\t\t\t\t\tlinks.splice(i, 1);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t\tgroupLinksInternal[link.hashSum] = link;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tconst linksArray: LinkID[] = [];\n\tconst linksObjects: IInternalLink[] = [];\n\tfor (const i in groupLinksPublic) {\n\t\tlinksArray.push(i);\n\t}\n\tfor (const i in groupLinksInternal) {\n\t\tlinksObjects.push(groupLinksInternal[i]);\n\t}\n\t// return everything in the current \"group\"\n\treturn { tasks: groupTasks, links: linksArray, processedLinks: linksObjects };\n}\n\nexport class ConnectedGroupsHelper {\n\tprivate _linksBuilder: any;\n\tprivate _gantt: any;\n\tconstructor(gantt: any, linksBuilder: any) {\n\t\tthis._linksBuilder = linksBuilder;\n\t\tthis._gantt = gantt;\n\t}\n\n\tgetConnectedGroupRelations = (id: TaskID): IInternalLink[] => {\n\t\tconst links = this._linksBuilder.getLinkedTasks();\n\t\tconst group = breadthFirstSearch(id, links, {});\n\t\treturn group.processedLinks;\n\t}\n\n\tgetConnectedGroup = (id: TaskID): IConnectedGroup | IConnectedGroup[] => {\n\t\tconst links = this._linksBuilder.getLinkedTasks();\n\t\tif (id !== undefined) {\n\t\t\tif (this._gantt.getTask(id).type === this._gantt.config.types.project) {\n\t\t\t\treturn { tasks: [], links: [] };\n\t\t\t}\n\n\t\t\tconst group = breadthFirstSearch(id, links, {});\n\t\t\treturn {\n\t\t\t\ttasks: group.tasks,\n\t\t\t\tlinks: group.links\n\t\t\t};\n\t\t} else {\n\t\t\treturn findGroups(links).map(group => ({ tasks: group.tasks, links: group.links }));\n\t\t}\n\t}\n}\n","import { TaskPlan } from \"./task_plan\";\n\nexport class AsapStrategy implements ISchedulingStrategy {\n\tstatic Create(gantt: any): AsapStrategy {\n\t\tconst instance = new AsapStrategy();\n\t\tinstance._gantt = gantt;\n\t\treturn instance;\n\t}\n\n\tprotected _gantt: any;\n\n\tresolveRelationDate(\n\t\ttaskId: TaskID,\n\t\tadjacentLinks: ITaskRelations,\n\t\tplansHash: IPlansHash\n\t): TaskPlan {\n\t\tlet minStart = null;\n\t\tlet linkId = null;\n\n\t\tlet defaultStart = null;\n\t\tconst task = this._gantt.getTask(taskId);\n\t\tconst relations = adjacentLinks.predecessors;\n\n\t\tlet minRelationDate = null;\n\t\tfor (let i = 0; i < relations.length; i++) {\n\t\t\tconst relation = relations[i];\n\n\t\t\t// .preferredStart still exists only to emulate pre 6.1 auto scheduling behavior\n\t\t\t// will be removed in future versions\n\t\t\t// TODO: remove .preferredStart in v7.0\n\t\t\tdefaultStart = relation.preferredStart;\n\n\t\t\tconst constraintDate = this.getEarliestStartDate(\n\t\t\t\trelation,\n\t\t\t\tplansHash,\n\t\t\t\ttask\n\t\t\t);\n\n\t\t\tif (this.isSmallerOrDefault(minRelationDate, constraintDate, task)) {\n\t\t\t\tminRelationDate = constraintDate;\n\t\t\t}\n\t\t\tif (\n\t\t\t\tthis.isSmallerOrDefault(defaultStart, constraintDate, task) &&\n\t\t\t\tthis.isSmallerOrDefault(minStart, constraintDate, task)\n\t\t\t) {\n\t\t\t\tminStart = constraintDate;\n\t\t\t\tlinkId = relation.id;\n\t\t\t}\n\t\t}\n\n\t\tif (!relations.length && this._gantt.config.project_start) {\n\t\t\tif (this.isSmallerOrDefault(task.start_date, this._gantt.config.project_start, task)) {\n\t\t\t\tminStart = this._gantt.config.project_start;\n\t\t\t}\n\t\t}\n\n\t\tlet maxEnd = null;\n\t\tif (minStart) {\n\t\t\tminStart = this._gantt.getClosestWorkTime({\n\t\t\t\tdate: minStart,\n\t\t\t\tdir: \"future\",\n\t\t\t\ttask\n\t\t\t});\n\t\t\tmaxEnd = this._gantt.calculateEndDate({\n\t\t\t\tstart_date: minStart,\n\t\t\t\tduration: task.duration,\n\t\t\t\ttask\n\t\t\t});\n\t\t}\n\n\t\tconst masterPlan = plansHash[taskId];\n\t\tconst currentPlan = TaskPlan.Create(masterPlan);\n\n\t\tcurrentPlan.link = linkId;\n\t\tcurrentPlan.task = taskId;\n\t\tcurrentPlan.start_date = minStart;\n\t\tcurrentPlan.end_date = maxEnd;\n\t\tcurrentPlan.kind = \"asap\";\n\n\t\tif (minRelationDate) {\n\t\t\tcurrentPlan.earliestSchedulingStart = minRelationDate;\n\t\t\tcurrentPlan.earliestSchedulingEnd = this._gantt.calculateEndDate({\n\t\t\t\tstart_date: minRelationDate,\n\t\t\t\tduration: task.duration,\n\t\t\t\ttask\n\t\t\t});\n\t\t}\n\n\t\treturn currentPlan;\n\t}\n\n\tprotected isEqual(dateA: Date, dateB: Date, task: ITask): boolean {\n\t\treturn !this._gantt._hasDuration(dateA, dateB, task);\n\t}\n\n\tprotected isFirstSmaller(small: Date, big: Date, task: ITask): boolean {\n\t\tif (small.valueOf() < big.valueOf() && !this.isEqual(small, big, task)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprotected isSmallerOrDefault(smallDate: Date, bigDate: Date, task: ITask): boolean {\n\t\treturn !!(!smallDate || this.isFirstSmaller(smallDate, bigDate, task));\n\t}\n\n\tprotected getPredecessorEndDate(id: TaskID, plansHash: IPlansHash): Date {\n\t\tconst plan = plansHash[id];\n\t\tconst task = this._gantt.getTask(id);\n\t\tlet res;\n\n\t\tif (!(plan && (plan.start_date || plan.end_date))) {\n\t\t\tres = task.end_date;\n\t\t} else if (plan.end_date) {\n\t\t\tres = plan.end_date;\n\t\t} else {\n\t\t\tres = this._gantt.calculateEndDate({\n\t\t\t\tstart_date: plan.start_date,\n\t\t\t\tduration: task.duration,\n\t\t\t\ttask\n\t\t\t});\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tprotected getEarliestStartDate(relation: IInternalLink, plansHash: IPlansHash, task: ITask): Date {\n\t\tconst predecessorEnd = this.getPredecessorEndDate(\n\t\t\trelation.source,\n\t\t\tplansHash\n\t\t);\n\t\tconst successor = task;\n\n\t\tlet successorStart = this._gantt.getClosestWorkTime({\n\t\t\tdate: predecessorEnd,\n\t\t\tdir: \"future\",\n\t\t\ttask: successor\n\t\t});\n\n\t\tif (\n\t\t\tpredecessorEnd &&\n\t\t\trelation.lag &&\n\t\t\trelation.lag * 1 === relation.lag * 1\n\t\t) {\n\t\t\tsuccessorStart = this._gantt.calculateEndDate({\n\t\t\t\tstart_date: predecessorEnd,\n\t\t\t\tduration: relation.lag * 1,\n\t\t\t\ttask: successor\n\t\t\t});\n\t\t}\n\n\t\treturn successorStart;\n\t}\n}\n","import { TaskPlan } from \"./task_plan\";\n\nexport class AlapStrategy implements ISchedulingStrategy {\n\tstatic Create(gantt: any): AlapStrategy {\n\t\tconst instance = new AlapStrategy();\n\t\tinstance._gantt = gantt;\n\t\treturn instance;\n\t}\n\n\tprotected _gantt: any;\n\n\n\tresolveRelationDate(taskId: TaskID, adjacentLinks: ITaskRelations, plansHash: IPlansHash): TaskPlan {\n\t\tlet maxEnd = null;\n\t\tlet linkId = null;\n\t\tlet maxStart = null;\n\t\tlet defaultStart = null;\n\t\tconst task = this._gantt.getTask(taskId);\n\t\tconst relations = adjacentLinks.successors;\n\t\tlet maxRelationDate = null;\n\t\tconst masterPlan = plansHash[taskId];\n\t\tfor (let i = 0; i < relations.length; i++) {\n\t\t\tconst relation = relations[i];\n\n\t\t\t// .preferredStart still exists only to emulate pre 6.1 auto scheduling behavior\n\t\t\t// will be removed in future versions\n\t\t\t// TODO: remove .preferredStart in v7.0\n\t\t\tdefaultStart = relation.preferredStart;\n\t\t\tconst constraintDate = this.getLatestEndDate(relation, plansHash, task);\n\t\t\tconst constraintStartDate = this._gantt.calculateEndDate({ start_date: constraintDate, duration: - task.duration, task });\n\n\t\t\tif (this.isGreaterOrDefault(maxRelationDate, constraintDate, task)) {\n\t\t\t\tmaxRelationDate = constraintDate;\n\t\t\t}\n\t\t\tif (this.isGreaterOrDefault(defaultStart, constraintStartDate, task) && this.isGreaterOrDefault(maxEnd, constraintDate, task)) {\n\t\t\t\tmaxEnd = constraintDate;\n\t\t\t\tmaxStart = constraintStartDate;\n\t\t\t\tlinkId = relation.id;\n\t\t\t}\n\t\t}\n\n\t\tif (!relations.length && this._gantt.config.project_end) {\n\t\t\tif (this.isGreaterOrDefault(this._gantt.config.project_end, task.end_date, task)) {\n\t\t\t\tmaxEnd = this._gantt.config.project_end;\n\t\t\t}\n\t\t}\n\n\t\tif (maxEnd) {\n\n\t\t\tmaxEnd = this._gantt.getClosestWorkTime({ date: maxEnd, dir: \"future\", task });\n\t\t\tmaxStart = this._gantt.calculateEndDate({ start_date: maxEnd, duration: - task.duration, task });\n\t\t}\n\n\t\tconst currentPlan = TaskPlan.Create(masterPlan);\n\n\t\tcurrentPlan.link = linkId;\n\t\tcurrentPlan.task = taskId;\n\t\tcurrentPlan.end_date = maxEnd;\n\t\tcurrentPlan.start_date = maxStart;\n\t\tcurrentPlan.kind = \"alap\";\n\n\t\tif (maxRelationDate) {\n\t\t\tcurrentPlan.latestSchedulingStart = this._gantt.calculateEndDate({ start_date: maxRelationDate, duration: - task.duration, task });\n\t\t\tcurrentPlan.latestSchedulingEnd = maxRelationDate;\n\t\t}\n\n\t\treturn currentPlan;\n\n\t}\n\n\tprotected isFirstSmaller(small: Date, big: Date, task: ITask): boolean {\n\t\tif (small.valueOf() < big.valueOf() && this._gantt._hasDuration(small, big, task)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprotected isGreaterOrDefault(smallDate: Date, bigDate: Date, task: ITask): boolean {\n\t\treturn !!(!smallDate || this.isFirstSmaller(bigDate, smallDate, task));\n\t}\n\n\tprotected getSuccessorStartDate(id: TaskID, plansHash: IPlansHash): Date {\n\t\tconst plan = plansHash[id];\n\t\tconst task = this._gantt.getTask(id);\n\t\tlet res;\n\n\t\tif (!(plan && (plan.start_date || plan.end_date))) {\n\t\t\tres = task.start_date;\n\t\t} else if (plan.start_date) {\n\t\t\tres = plan.start_date;\n\t\t} else {\n\t\t\tres = this._gantt.calculateEndDate({ start_date: plan.end_date, duration: - task.duration, task });\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tprotected getLatestEndDate(relation: IInternalLink, plansHash: IPlansHash, task: ITask) {\n\t\tconst successorStart = this.getSuccessorStartDate(relation.target, plansHash);\n\t\tconst predecessor = task;\n\n\t\tlet predecessorEnd = this._gantt.getClosestWorkTime({ date: successorStart, dir: \"past\", task: predecessor });\n\n\t\tif (predecessorEnd && relation.lag && relation.lag * 1 === relation.lag * 1) {\n\t\t\tpredecessorEnd = this._gantt.calculateEndDate({ start_date: predecessorEnd, duration: -relation.lag * 1, task: predecessor });\n\t\t}\n\n\t\treturn predecessorEnd;\n\t}\n}","import { AlapStrategy } from \"./alap_strategy\";\nimport { AsapStrategy } from \"./asap_strategy\";\nimport { ConstraintTypes } from \"./constraint_types\";\nimport { ConstraintsHelper } from \"./constraints\";\nimport { TaskPlan } from \"./task_plan\";\n\nexport class AutoSchedulingPlanner {\n\tprivate _gantt: any;\n\tprivate _constraintsHelper: ConstraintsHelper;\n\tprivate _graphHelper: any;\n\tprivate _asapStrategy: AsapStrategy;\n\tprivate _alapStrategy: AlapStrategy;\n\n\tconstructor(\n\t\tgantt: any,\n\t\tgraphHelper: any,\n\t\tconstraintsHelper: ConstraintsHelper\n\t) {\n\t\tthis._gantt = gantt;\n\t\tthis._constraintsHelper = constraintsHelper;\n\t\tthis._graphHelper = graphHelper;\n\t\tthis._asapStrategy = AsapStrategy.Create(gantt);\n\t\tthis._alapStrategy = AlapStrategy.Create(gantt);\n\t}\n\n\tgeneratePlan(relations: IInternalLink[], constraints: ITask[]): TaskPlan[] {\n\t\tconst graphHelper = this._graphHelper;\n\t\tconst gantt = this._gantt;\n\t\tconst constraintsHelper = this._constraintsHelper;\n\t\tconst alapStrategy = this._alapStrategy;\n\t\tconst asapStrategy = this._asapStrategy;\n\n\t\tconst {\n\t\t\torderedIds,\n\t\t\treversedIds,\n\t\t\trelationsMap,\n\t\t\tplansHash } = this.buildWorkCollections(relations, constraints, graphHelper);\n\n\t\tlet result: TaskPlan[];\n\n\t\tthis.processConstraints(orderedIds, plansHash, gantt, constraintsHelper);\n\n\t\tif (gantt.config.schedule_from_end) {\n\t\t\t// when scheduling from end - iterate tasks from end and schedule them as late as possible\n\t\t\t// after that - iterate tasks from start and schedule asap tasks\n\t\t\tresult = this.iterateTasks(reversedIds, orderedIds, constraintsHelper.isAlapTask, alapStrategy, asapStrategy, relationsMap, plansHash);\n\t\t} else {\n\t\t\t// when scheduling from end - iterate tasks from start and schedule them as soon as possible\n\t\t\t// after that - iterate tasks from end and schedule asap alap\n\t\t\tresult = this.iterateTasks(orderedIds, reversedIds, constraintsHelper.isAsapTask, asapStrategy, alapStrategy, relationsMap, plansHash);\n\t\t}\n\t\treturn result;\n\t}\n\n\tapplyProjectPlan(projectPlan: TaskPlan[]): ITask[] {\n\t\tconst gantt = this._gantt;\n\n\t\tlet plan: TaskPlan;\n\t\tlet task: ITask;\n\t\tlet link: ILink;\n\t\tlet reason: ITask;\n\n\t\tconst updateTasks = [];\n\t\tfor (let i = 0; i < projectPlan.length; i++) {\n\t\t\tlink = null;\n\t\t\treason = null;\n\t\t\tplan = projectPlan[i];\n\n\t\t\tif (!plan.task) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttask = gantt.getTask(plan.task);\n\t\t\tif (plan.link) {\n\t\t\t\tlink = gantt.getLink(plan.link);\n\t\t\t\tif (plan.kind === \"asap\") {\n\t\t\t\t\treason = this._gantt.getTask(link.source);\n\t\t\t\t} else {\n\t\t\t\t\t// alap tasks are scheduled by their successors\n\t\t\t\t\treason = this._gantt.getTask(link.target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet newDate = null;\n\t\t\tif (\n\t\t\t\tplan.start_date &&\n\t\t\t\ttask.start_date.valueOf() !== plan.start_date.valueOf()\n\t\t\t) {\n\t\t\t\tnewDate = plan.start_date;\n\t\t\t}\n\n\t\t\tif (!newDate) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttask.start_date = newDate;\n\t\t\ttask.end_date = gantt.calculateEndDate(task);\n\n\t\t\tupdateTasks.push(task.id);\n\t\t\tgantt.callEvent(\"onAfterTaskAutoSchedule\", [\n\t\t\t\ttask,\n\t\t\t\tnewDate,\n\t\t\t\tlink,\n\t\t\t\treason\n\t\t\t]);\n\t\t}\n\t\treturn updateTasks;\n\t}\n\n\tprotected iterateTasks(\n\t\tmainSequence: TaskID[],\n\t\tsecondarySequence: TaskID[],\n\t\tisMainSequence: (task: ITask) => boolean,\n\t\tmainSequenceStrategy: ISchedulingStrategy,\n\t\tsecondarySequenceStrategy: ISchedulingStrategy,\n\t\trelationsMap: ITaskLinksMap,\n\t\tplansHash: IPlansHash\n\n\t): TaskPlan[] {\n\t\tconst gantt = this._gantt;\n\t\tconst result: TaskPlan[] = [];\n\n\t\tfor (let i = 0; i < mainSequence.length; i++) {\n\t\t\tconst currentId = mainSequence[i];\n\t\t\tconst task = gantt.getTask(currentId);\n\t\t\tconst plan = mainSequenceStrategy.resolveRelationDate(\n\t\t\t\tcurrentId,\n\t\t\t\trelationsMap[currentId],\n\t\t\t\tplansHash\n\t\t\t);\n\t\t\tthis.limitPlanDates(task, plan);\n\t\t\tif (isMainSequence(task)) {\n\t\t\t\tthis.processResolvedDate(task, plan, result, plansHash);\n\t\t\t} else {\n\t\t\t\tplansHash[task.id] = plan;\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < secondarySequence.length; i++) {\n\t\t\tconst currentId = secondarySequence[i];\n\t\t\tconst task = gantt.getTask(currentId);\n\n\t\t\tif (!isMainSequence(task)) {\n\t\t\t\tconst plan = secondarySequenceStrategy.resolveRelationDate(\n\t\t\t\t\tcurrentId,\n\t\t\t\t\trelationsMap[currentId],\n\t\t\t\t\tplansHash\n\t\t\t\t);\n\t\t\t\tthis.limitPlanDates(task, plan);\n\t\t\t\tthis.processResolvedDate(task, plan, result, plansHash);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprotected processResolvedDate(\n\t\ttask: ITask,\n\t\tplan: TaskPlan,\n\t\tresult: TaskPlan[],\n\t\tplansHash: any\n\t): void {\n\t\tif (plan.start_date && this._gantt.isLinkExists(plan.link)) {\n\t\t\tlet link = null;\n\t\t\tlet reason = null;\n\t\t\tif (plan.link) {\n\t\t\t\tlink = this._gantt.getLink(plan.link);\n\t\t\t\tif (plan.kind === \"asap\") {\n\t\t\t\t\treason = this._gantt.getTask(link.source);\n\t\t\t\t} else {\n\t\t\t\t\t// alap tasks are scheduled by their successors\n\t\t\t\t\treason = this._gantt.getTask(link.target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ttask.start_date.valueOf() !== plan.start_date.valueOf() &&\n\t\t\t\tthis._gantt.callEvent(\"onBeforeTaskAutoSchedule\", [\n\t\t\t\t\ttask,\n\t\t\t\t\tplan.start_date,\n\t\t\t\t\tlink,\n\t\t\t\t\treason\n\t\t\t\t]) === false\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tplansHash[task.id] = plan;\n\t\tif (plan.start_date) {\n\t\t\tresult.push(plan);\n\t\t}\n\t}\n\n\tprotected limitPlanDates(task: ITask, plan: TaskPlan): TaskPlan {\n\t\tconst effectiveStart = plan.start_date || task.start_date;\n\n\t\tif (plan.earliestStart) {\n\t\t\tif (effectiveStart < plan.earliestStart) {\n\t\t\t\tplan.start_date = plan.earliestStart;\n\t\t\t\tplan.end_date = plan.earliestEnd;\n\t\t\t}\n\t\t}\n\n\t\tif (plan.latestStart) {\n\t\t\tif (effectiveStart > plan.latestStart) {\n\t\t\t\tplan.start_date = plan.latestStart;\n\t\t\t\tplan.end_date = plan.latestEnd;\n\t\t\t}\n\t\t}\n\n\t\tif (plan.latestSchedulingStart && effectiveStart > plan.latestSchedulingStart) {\n\t\t\tplan.start_date = plan.latestSchedulingStart;\n\t\t\tplan.end_date = plan.latestSchedulingEnd;\n\t\t}\n\n\t\tif (plan.earliestSchedulingStart && effectiveStart < plan.earliestSchedulingStart) {\n\t\t\tplan.start_date = plan.earliestSchedulingStart;\n\t\t\tplan.end_date = plan.earliestSchedulingEnd;\n\t\t}\n\n\t\tif (plan.start_date) { // start/end dates are either both defined or both not\n\t\t\tif (plan.start_date > plan.latestSchedulingStart ||\n\t\t\t\tplan.start_date < plan.earliestSchedulingStart ||\n\t\t\t\tplan.start_date > plan.latestStart ||\n\t\t\t\tplan.start_date < plan.earliestStart ||\n\t\t\t\tplan.end_date > plan.latestSchedulingEnd ||\n\t\t\t\tplan.end_date < plan.earliestSchedulingEnd ||\n\t\t\t\tplan.end_date > plan.latestEnd ||\n\t\t\t\tplan.end_date < plan.earliestEnd) {\n\n\t\t\t\tplan.conflict = true;\n\t\t\t}\n\t\t}\n\t\treturn plan;\n\t}\n\n\tprotected buildWorkCollections(relations: IInternalLink[], constraints: ITask[], graphHelper: any) {\n\t\tconst gantt = this._gantt;\n\t\tconst orderedIds: TaskID[] = graphHelper.topologicalSort(relations);\n\t\tconst reversedIds: TaskID[] = orderedIds.slice().reverse();\n\t\tconst plansHash: IPlansHash = {};\n\n\t\tconst relationsMap: ITaskLinksMap = {};\n\t\tfor (let i = 0, len = orderedIds.length; i < len; i++) {\n\t\t\tconst id = orderedIds[i];\n\t\t\tconst task = gantt.getTask(id);\n\t\t\tif (task.auto_scheduling === false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trelationsMap[id] = {\n\t\t\t\tsuccessors: [],\n\t\t\t\tpredecessors: []\n\t\t\t};\n\n\t\t\tplansHash[id] = null;\n\t\t}\n\n\t\tfor (let i = 0, len = constraints.length; i < len; i++) {\n\t\t\tconst task = constraints[i];\n\n\t\t\tif (plansHash[task.id] === undefined) {\n\t\t\t\treversedIds.unshift(task.id);\n\t\t\t\torderedIds.unshift(task.id);\n\t\t\t\tplansHash[task.id] = null;\n\t\t\t\trelationsMap[task.id] = {\n\t\t\t\t\tsuccessors: [],\n\t\t\t\t\tpredecessors: []\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0, len = relations.length; i < len; i++) {\n\t\t\tconst rel = relations[i];\n\t\t\tif (relationsMap[rel.source]) {\n\t\t\t\trelationsMap[rel.source].successors.push(rel);\n\t\t\t}\n\n\t\t\tif (relationsMap[rel.target]) {\n\t\t\t\trelationsMap[rel.target].predecessors.push(rel);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\torderedIds,\n\t\t\treversedIds,\n\t\t\trelationsMap,\n\t\t\tplansHash\n\t\t};\n\t}\n\n\tprotected processConstraints(orderedIds: TaskID[], plansHash: IPlansHash, gantt: any, constraintsHelper: ConstraintsHelper) {\n\t\tfor (let i = 0; i < orderedIds.length; i++) {\n\t\t\tconst currentId = orderedIds[i];\n\t\t\tconst task = gantt.getTask(currentId);\n\n\t\t\tconst constraintType = constraintsHelper.getConstraintType(task);\n\t\t\tif (\n\t\t\t\tconstraintType &&\n\t\t\t\tconstraintType !== ConstraintTypes.ASAP &&\n\t\t\t\tconstraintType !== ConstraintTypes.ALAP\n\t\t\t) {\n\t\t\t\tconst plan = constraintsHelper.processConstraint(\n\t\t\t\t\ttask,\n\t\t\t\t\tTaskPlan.Create()\n\t\t\t\t);\n\t\t\t\tplansHash[task.id] = plan;\n\t\t\t}\n\t\t}\n\t}\n}\n","import { ConstraintTypes } from \"./constraint_types\";\nimport { TaskPlan } from \"./task_plan\";\n\nexport class ConstraintsHelper {\n\tstatic Create(gantt: any): ConstraintsHelper {\n\t\treturn new ConstraintsHelper(gantt);\n\t}\n\n\tprivate _gantt: any;\n\tprivate constructor(gantt: any) {\n\t\tthis._gantt = gantt;\n\t}\n\n\tisAsapTask = (task: ITask): boolean => {\n\t\tconst constraintType = this.getConstraintType(task);\n\t\tif (this._gantt.config.schedule_from_end) {\n\t\t\tif (constraintType === ConstraintTypes.ASAP) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (constraintType === ConstraintTypes.ALAP) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tisAlapTask = (task: ITask): boolean => {\n\t\treturn !this.isAsapTask(task);\n\t}\n\n\tgetConstraintType = (task: ITask): ConstraintTypes => {\n\t\t// in case of backward scheduling, tasks without explicit constraints are considered ALAP tasks\n\t\tif (task.constraint_type) {\n\t\t\treturn task.constraint_type;\n\t\t} else if (this._gantt.config.schedule_from_end) {\n\t\t\treturn ConstraintTypes.ALAP;\n\t\t} else {\n\t\t\treturn ConstraintTypes.ASAP;\n\t\t}\n\t}\n\n\thasConstraint = (task: ITask): boolean => {\n\t\treturn !!this.getConstraintType(task);\n\t}\n\n\tprocessConstraint = (task: ITask, plan: TaskPlan): TaskPlan => {\n\t\tif (this.hasConstraint(task)) {\n\t\t\tif (\n\t\t\t\ttask.constraint_type === ConstraintTypes.ALAP ||\n\t\t\t\ttask.constraint_type === ConstraintTypes.ASAP\n\t\t\t) {\n\t\t\t\t// this kind of constraint is calculated after main scheduling\n\t\t\t} else {\n\t\t\t\tconst constraintDate = task.constraint_date;\n\n\t\t\t\tconst newPlan = TaskPlan.Create(plan);\n\t\t\t\tnewPlan.task = task.id;\n\n\t\t\t\tswitch (task.constraint_type) {\n\t\t\t\t\tcase ConstraintTypes.SNET:\n\t\t\t\t\t\tnewPlan.earliestStart = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.earliestEnd = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: newPlan.earliestStart,\n\t\t\t\t\t\t\tduration: task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.SNLT:\n\t\t\t\t\t\tnewPlan.latestStart = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.latestEnd = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: newPlan.latestStart,\n\t\t\t\t\t\t\tduration: task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.FNET:\n\t\t\t\t\t\tnewPlan.earliestStart = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: constraintDate,\n\t\t\t\t\t\t\tduration: -task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.earliestEnd = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.FNLT:\n\t\t\t\t\t\tnewPlan.latestStart = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: constraintDate,\n\t\t\t\t\t\t\tduration: -task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.latestEnd = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.MSO:\n\t\t\t\t\t\tnewPlan.earliestStart = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.earliestEnd = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: newPlan.earliestStart,\n\t\t\t\t\t\t\tduration: task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.latestStart = newPlan.earliestStart;\n\t\t\t\t\t\tnewPlan.latestEnd = newPlan.earliestEnd;\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.MFO:\n\t\t\t\t\t\tnewPlan.earliestStart = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: constraintDate,\n\t\t\t\t\t\t\tduration: -task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.earliestEnd = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: newPlan.earliestStart,\n\t\t\t\t\t\t\tduration: task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.latestStart = newPlan.earliestStart;\n\t\t\t\t\t\tnewPlan.latestEnd = newPlan.earliestEnd;\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\treturn newPlan;\n\t\t\t}\n\t\t}\n\n\t\treturn plan;\n\t}\n\n\tgetConstraints = (id: TaskID, relations: IInternalLink[]): ITask[] => {\n\t\tconst result = [];\n\t\tconst tasks = {};\n\n\t\tconst store = (task: any) => {\n\t\t\tif (tasks[task.id]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.hasConstraint(task) && !this._gantt.isSummaryTask(task)) {\n\t\t\t\ttasks[task.id] = task;\n\t\t\t}\n\t\t};\n\n\t\tif (this._gantt.isTaskExists(id)) {\n\t\t\tconst task = this._gantt.getTask(id);\n\t\t\tstore(task);\n\t\t}\n\n\t\tthis._gantt.eachTask(task => store(task), id);\n\n\t\tlet current;\n\t\tif (relations) {\n\t\t\tfor (let i = 0; i < relations.length; i++) {\n\t\t\t\tconst rel = relations[i];\n\t\t\t\tif (!tasks[rel.target]) {\n\t\t\t\t\tcurrent = this._gantt.getTask(rel.target);\n\t\t\t\t\tstore(current);\n\t\t\t\t}\n\t\t\t\tif (!tasks[rel.source]) {\n\t\t\t\t\tcurrent = this._gantt.getTask(rel.source);\n\t\t\t\t\tstore(current);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const taskId in tasks) {\n\t\t\tresult.push(tasks[taskId]);\n\t\t}\n\n\t\treturn result;\n\t}\n}\n","require(\"../core/relations/links_common\")(gantt);\n\nvar linksBuilder = require(\"../core/relations/links_builder\")(gantt);\nvar graphHelper = require(\"../core/relations/graph_helper\")(gantt);\nvar ConstraintTypes = require(\"./auto_scheduling/constraint_types\").ConstraintTypes;\n\nvar constraintsHelper = require(\"./auto_scheduling/constraints\").ConstraintsHelper.Create(\n\tgantt\n);\nvar AutoSchedulingPlanner = require(\"./auto_scheduling/planner\")\n\t.AutoSchedulingPlanner;\n\nvar planner = new AutoSchedulingPlanner(gantt, graphHelper, constraintsHelper);\n\nvar ConnectedGroupsHelper = require(\"./auto_scheduling/connected_groups\")\n\t.ConnectedGroupsHelper;\nvar connectedGroups = new ConnectedGroupsHelper(gantt, linksBuilder);\n\nvar LoopsFinder = require(\"./auto_scheduling/loops_finder\").LoopsFinder;\n\nvar loopsFinder = new LoopsFinder(\n\tgantt,\n\tgraphHelper,\n\tlinksBuilder\n);\n\ngantt.getConnectedGroup = connectedGroups.getConnectedGroup;\ngantt.getConstraintType = constraintsHelper.getConstraintType;\ngantt.getConstraintLimitations = function (task) {\n\tvar plan = constraintsHelper.processConstraint(task, null);\n\treturn {\n\t\tearliestStart: plan.earliestStart || null,\n\t\tearliestEnd: plan.earliestEnd || null,\n\t\tlatestStart: plan.latestStart || null,\n\t\tlatestEnd: plan.latestEnd || null\n\t};\n};\n\ngantt.isCircularLink = loopsFinder.isCircularLink;\ngantt.findCycles = loopsFinder.findCycles;\n\ngantt.config.constraint_types = ConstraintTypes;\ngantt.config.auto_scheduling = false;\ngantt.config.auto_scheduling_descendant_links = false;\ngantt.config.auto_scheduling_initial = true;\ngantt.config.auto_scheduling_strict = false;\ngantt.config.auto_scheduling_move_projects = true;\ngantt.config.project_start = null;\ngantt.config.project_end = null;\ngantt.config.schedule_from_end = false;\n\nfunction preferInitialTaskDates(startTask, relations) {\n\t// TODO: remove in 7.0\n\tif (!gantt.config.auto_scheduling_compatibility) {\n\t\treturn;\n\t}\n\n\t// .preferredStart still exists only to emulate pre 6.1 auto scheduling behavior\n\t// will be removed in future versions\n\tfor (var i = 0; i < relations.length; i++) {\n\t\tvar rel = relations[i];\n\t\tvar task = gantt.getTask(rel.target);\n\n\t\tif (!gantt.config.auto_scheduling_strict || rel.target == startTask) {\n\t\t\trel.preferredStart = new Date(task.start_date);\n\t\t}\n\t}\n}\n\nfunction updateParentsAndCallEvents(updatedTasks) {\n\tfunction resetTime(task) {\n\t\tif (batchUpdate)\n\t\t\treturn;\n\n\t\tvar start = task.start_date.valueOf(),\n\t\t\tend = task.end_date.valueOf();\n\n\t\tgantt.resetProjectDates(task);\n\t\tif (task.start_date.valueOf() != start || task.end_date.valueOf() != end) {\n\t\t\tbatchUpdate = true;\n\t\t\treturn;\n\t\t}\n\t\tvar children = gantt.getChildren(task.id);\n\t\tfor (var i = 0; !batchUpdate && i < children.length; i++) {\n\t\t\tresetTime(gantt.getTask(children[i]));\n\t\t}\n\t}\n\n\tvar batchUpdate = false;\n\t// call batchUpdate (full repaint) only if we update multiple tasks,\n\tif (updatedTasks.length == 1) {\n\t\tgantt.eachParent(resetTime, updatedTasks[0]);\n\t} else if (updatedTasks.length) {\n\t\tbatchUpdate = true;\n\t}\n\n\tfunction payload() {\n\t\tfor (var i = 0; i < updatedTasks.length; i++) {\n\t\t\tgantt.updateTask(updatedTasks[i]);\n\t\t}\n\t}\n\tif (batchUpdate) {\n\t\tgantt.batchUpdate(payload);\n\t} else {\n\t\tpayload();\n\t}\n}\n\ngantt._autoSchedule = function (id, relations) {\n\tif (gantt.callEvent(\"onBeforeAutoSchedule\", [id]) === false) {\n\t\treturn;\n\t}\n\tgantt._autoscheduling_in_progress = true;\n\n\tvar constraints = constraintsHelper.getConstraints(\n\t\tid,\n\t\tgantt.isTaskExists(id) ? relations : null\n\t);\n\n\tvar updatedTasks = [];\n\n\tvar cycles = graphHelper.findLoops(relations);\n\tif (cycles.length) {\n\t\tgantt.callEvent(\"onAutoScheduleCircularLink\", [cycles]);\n\t} else {\n\t\tpreferInitialTaskDates(id, relations);\n\n\t\tvar plan = planner.generatePlan(relations, constraints);\n\t\tupdatedTasks = planner.applyProjectPlan(plan);\n\n\t\tupdateParentsAndCallEvents(updatedTasks);\n\t}\n\n\tgantt._autoscheduling_in_progress = false;\n\tgantt.callEvent(\"onAfterAutoSchedule\", [id, updatedTasks]);\n};\n\ngantt.autoSchedule = function (id, inclusive) {\n\tif (inclusive === undefined) {\n\t\tinclusive = true;\n\t} else {\n\t\tinclusive = !!inclusive;\n\t}\n\n\tvar relations;\n\tif (id !== undefined) {\n\t\tif (gantt.config.auto_scheduling_compatible) {\n\t\t\tlinksBuilder.getLinkedTasks(id, inclusive);\n\t\t} else {\n\t\t\trelations = connectedGroups.getConnectedGroupRelations(id);\n\t\t}\n\t} else {\n\t\trelations = linksBuilder.getLinkedTasks();\n\t}\n\n\tgantt._autoSchedule(id, relations);\n};\n\ngantt.attachEvent(\"onTaskLoading\", function (task) {\n\tif (task.constraint_date && typeof task.constraint_date === \"string\") {\n\t\ttask.constraint_date = gantt.date.parseDate(task.constraint_date, \"parse_date\");\n\t}\n\ttask.constraint_type = gantt.getConstraintType(task);\n\treturn true;\n});\ngantt.attachEvent(\"onTaskCreated\", function (task) {\n\ttask.constraint_type = gantt.getConstraintType(task);\n\treturn true;\n});\n\nvar attachUIHandlers = require(\"./auto_scheduling/ui_handlers\").attachUIHandlers;\nattachUIHandlers(gantt, linksBuilder, loopsFinder, connectedGroups);\n","export class TaskPlan implements ITaskPlan {\n\tstatic Create(parent?: TaskPlan): TaskPlan {\n\t\tconst plan = new TaskPlan();\n\t\tif (parent) {\n\t\t\tfor (const i in plan) {\n\t\t\t\tif (parent[i] !== undefined) {\n\t\t\t\t\tplan[i] = parent[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn plan;\n\t}\n\n\tpublic link: string | number;\n\tpublic task: string | number;\n\t// tslint:disable-next-line variable-name\n\tpublic start_date: Date | null;\n\t// tslint:disable-next-line variable-name\n\tpublic end_date: Date | null;\n\n\tpublic latestStart: Date;\n\tpublic earliestStart: Date;\n\tpublic earliestEnd: Date;\n\tpublic latestEnd: Date;\n\n\tpublic latestSchedulingStart: Date;\n\tpublic earliestSchedulingStart: Date;\n\tpublic latestSchedulingEnd: Date;\n\tpublic earliestSchedulingEnd: Date;\n\n\tpublic kind: string;\n\tpublic conflict: boolean;\n\n\tconstructor() {\n\t\tthis.link = null;\n\t\tthis.task = null;\n\t\tthis.start_date = null;\n\t\tthis.end_date = null;\n\t\tthis.latestStart = null;\n\t\tthis.earliestStart = null;\n\t\tthis.earliestEnd = null;\n\t\tthis.latestEnd = null;\n\t\tthis.latestSchedulingStart = null;\n\t\tthis.earliestSchedulingStart = null;\n\t\tthis.latestSchedulingEnd = null;\n\t\tthis.earliestSchedulingEnd = null;\n\t\tthis.kind = \"asap\";\n\t\tthis.conflict = false;\n\t}\n}"],"sourceRoot":""}